diff --git a/live_trader/adapters/base_broker.py b/live_trader/adapters/base_broker.py
index 62ff01b..c12a92b 100644
--- a/live_trader/adapters/base_broker.py
+++ b/live_trader/adapters/base_broker.py
@@ -70,6 +70,25 @@ class BaseLiveDataProvider(ABC):
 
 class BaseLiveBroker(ABC):
     """交易执行器适配器的抽象基类，模拟 backtrader 的 broker 接口"""
+    # 自愈节流：1 秒一轮足够覆盖常见回调抖动，又不会产生高频噪音
+    SELF_HEAL_MIN_INTERVAL_SECONDS = 1.0
+    # 无回调兜底：deferred 至少每 2 秒尝试一次重放，避免“只剩现金”卡住
+    DEFERRED_REPLAY_INTERVAL_SECONDS = 2.0
+    # 缓冲重试等待告警阈值
+    BUFFERED_RETRY_WARN_SECONDS = 20.0
+    # 在途快照查询的轻量重试参数（用于吸收短暂网络抖动）
+    PENDING_SNAPSHOT_RETRY_ATTEMPTS = 2
+    PENDING_SNAPSHOT_RETRY_SLEEP_SECONDS = 0.05
+    # 连续快照失败触发“不确定模式”。
+    # 夜间无人值守策略下，不确定状态里宁可少交易，也不能新增风险敞口。
+    PENDING_SNAPSHOT_UNCERTAIN_FAILS = 3
+    PENDING_SNAPSHOT_UNCERTAIN_TTL_SECONDS = 60.0
+    # 空快照清理的最短等待时间（配合连续次数阈值使用）
+    PENDING_SELL_CLEAR_EMPTY_MIN_SECONDS = 20.0
+    ACTIVE_BUY_CLEAR_EMPTY_MIN_SECONDS = 20.0
+    # 订单状态记忆容量与生存期（用于快照不可用时的安全回退）
+    ORDER_STATE_MEMORY_MAX_ITEMS = 5000
+    ORDER_STATE_MEMORY_TTL_SECONDS = 12 * 3600
 
     def __init__(self, context, cash_override=None, commission_override=None, slippage_override=None,):
         self.is_live = True
@@ -89,10 +108,27 @@ class BaseLiveBroker(ABC):
         self._active_buys = {}
         # IB 等柜台会先推 Inactive 再推 Cancelled；Rejected 重试需等待原单真正出清
         self._buffered_rejected_retries = {}
+        self._active_buy_empty_snapshots = 0
+        self._strategy_deferred_empty_since = None
+        self._last_deferred_replay_ts = 0.0
         # 虚拟账本读写锁
         self._ledger_lock = threading.RLock()
         # 风控锁定黑名单
         self._risk_locked_symbols = set()
+        # 自愈心跳节流
+        self._last_self_heal_ts = 0.0
+        # 连续“卖单在途为空”快照计数，用于防止单次快照抖动误清理
+        self._pending_sell_empty_snapshots = 0
+        self._pending_sell_empty_since = None
+        self._active_buy_empty_since = None
+        # 订单状态记忆：在途快照异常时，仅基于“已观察到的终态”做安全回退
+        self._order_state_memory = {}
+        # 在途快照健康状态与不确定模式窗口
+        self._pending_snapshot_fail_count = 0
+        self._pending_snapshot_fail_since = None
+        self._uncertain_mode_until = 0.0
+        self._last_uncertain_replay_skip_log_ts = 0.0
+        self._last_buffered_snapshot_skip_log_ts = 0.0
 
     @property
     def safety_multiplier(self):
@@ -260,6 +296,10 @@ class BaseLiveBroker(ABC):
         lot_size = config.LOT_SIZE
         cash = self.get_cash()
 
+        # 策略约束：状态不确定时禁止新增敞口，只允许入队等待恢复。
+        if self.is_uncertain_mode():
+            return self._queue_uncertain_buy_retry(self.order_target_percent, data, target_pct, **kwargs)
+
         # 动态安全垫
         buffer_rate = self.safety_multiplier
         estimated_cost = shares * price * buffer_rate
@@ -292,6 +332,10 @@ class BaseLiveBroker(ABC):
         lot_size = config.LOT_SIZE
         cash = self.get_cash()
 
+        # 策略约束：状态不确定时禁止新增敞口，只允许入队等待恢复。
+        if self.is_uncertain_mode():
+            return self._queue_uncertain_buy_retry(self.order_target_value, data, target_value, **kwargs)
+
         # 动态安全垫
         buffer_rate = self.safety_multiplier
         estimated_cost = shares * price * buffer_rate
@@ -359,6 +403,258 @@ class BaseLiveBroker(ABC):
 
         return fallback
 
+    @staticmethod
+    def _resolve_proxy_symbol(proxy, fallback='Unknown'):
+        """尽可能从不同代理结构中提取标的名，用于人类可读日志。"""
+        try:
+            data = getattr(proxy, 'data', None)
+            if data is not None:
+                name = getattr(data, '_name', None)
+                if name:
+                    return str(name)
+        except Exception:
+            pass
+
+        candidate_paths = [
+            ('trade', 'contract', 'symbol'),
+            ('platform_order', 'symbol'),
+            ('raw_order', 'symbol'),
+            ('symbol',),
+        ]
+        for path in candidate_paths:
+            cur = proxy
+            ok = True
+            for attr in path:
+                if not hasattr(cur, attr):
+                    ok = False
+                    break
+                cur = getattr(cur, attr)
+            if ok and cur:
+                return str(cur)
+        return fallback
+
+    def _trim_order_state_memory(self, now_ts=None):
+        now = float(now_ts if now_ts is not None else time.time())
+        mem = getattr(self, '_order_state_memory', None)
+        if not isinstance(mem, dict) or not mem:
+            return
+
+        ttl_cfg = getattr(config, 'BROKER_ORDER_STATE_MEMORY_TTL_SECONDS', self.ORDER_STATE_MEMORY_TTL_SECONDS)
+        try:
+            ttl = float(ttl_cfg)
+        except Exception:
+            ttl = float(self.ORDER_STATE_MEMORY_TTL_SECONDS)
+        if ttl > 0:
+            stale_keys = [
+                k for k, v in mem.items()
+                if now - float((v or {}).get('updated_at', 0.0) or 0.0) > ttl
+            ]
+            for k in stale_keys:
+                mem.pop(k, None)
+
+        max_items_cfg = getattr(config, 'BROKER_ORDER_STATE_MEMORY_MAX_ITEMS', self.ORDER_STATE_MEMORY_MAX_ITEMS)
+        try:
+            max_items = int(max_items_cfg)
+        except Exception:
+            max_items = int(self.ORDER_STATE_MEMORY_MAX_ITEMS)
+        max_items = max(100, max_items)
+        overflow = len(mem) - max_items
+        if overflow > 0:
+            ordered = sorted(mem.items(), key=lambda kv: float((kv[1] or {}).get('updated_at', 0.0) or 0.0))
+            for key, _ in ordered[:overflow]:
+                mem.pop(key, None)
+
+    def _remember_order_state(self, proxy):
+        """记录订单最近状态，用于快照不可用时的保守/安全回退。"""
+        oid = str(getattr(proxy, 'id', '') or '').strip()
+        if not oid:
+            return
+
+        symbol = self._resolve_proxy_symbol(proxy)
+        side = ''
+        try:
+            if proxy.is_buy():
+                side = 'BUY'
+            elif proxy.is_sell():
+                side = 'SELL'
+        except Exception:
+            side = ''
+
+        terminal = False
+        try:
+            terminal = bool(proxy.is_completed() or proxy.is_canceled() or proxy.is_rejected())
+        except Exception:
+            terminal = False
+
+        pending = False
+        if not terminal:
+            try:
+                pending = bool(proxy.is_pending() or proxy.is_accepted())
+            except Exception:
+                pending = False
+
+        self._order_state_memory[oid] = {
+            'symbol': str(symbol or ''),
+            'side': side,
+            'terminal': terminal,
+            'pending': pending,
+            'updated_at': time.time(),
+        }
+        self._trim_order_state_memory()
+
+    def _pending_state_from_memory(self, order_id, symbol=None, side=None):
+        oid = str(order_id or '').strip()
+        if not oid:
+            return None
+
+        item = getattr(self, '_order_state_memory', {}).get(oid)
+        if not isinstance(item, dict):
+            return None
+
+        side_norm = str(side).upper() if side else ''
+        item_side = str(item.get('side', '')).upper()
+        if side_norm and item_side and side_norm != item_side:
+            return None
+
+        symbol_norm = str(symbol).upper() if symbol else ''
+        item_symbol = str(item.get('symbol', '')).upper()
+        if symbol_norm and item_symbol:
+            # Unknown 视为“无法提供符号约束”，不用于否决该条状态记忆。
+            if item_symbol not in {'UNKNOWN', 'UNK', '?'}:
+                if item_symbol != symbol_norm and item_symbol != symbol_norm.split('.')[0]:
+                    return None
+
+        if bool(item.get('terminal')):
+            return False
+        if bool(item.get('pending')):
+            return True
+        return None
+
+    def _mark_pending_snapshot_success(self):
+        with self._ledger_lock:
+            self._pending_snapshot_fail_count = 0
+            self._pending_snapshot_fail_since = None
+
+    def _mark_pending_snapshot_failure(self, reason="unknown"):
+        now_ts = time.time()
+        with self._ledger_lock:
+            self._pending_snapshot_fail_count = int(getattr(self, '_pending_snapshot_fail_count', 0)) + 1
+            if self._pending_snapshot_fail_since is None:
+                self._pending_snapshot_fail_since = now_ts
+
+            fail_cfg = getattr(
+                config,
+                'BROKER_PENDING_SNAPSHOT_UNCERTAIN_FAILS',
+                self.PENDING_SNAPSHOT_UNCERTAIN_FAILS
+            )
+            ttl_cfg = getattr(
+                config,
+                'BROKER_PENDING_SNAPSHOT_UNCERTAIN_TTL_SECONDS',
+                self.PENDING_SNAPSHOT_UNCERTAIN_TTL_SECONDS
+            )
+
+            try:
+                fail_threshold = int(fail_cfg)
+            except Exception:
+                fail_threshold = int(self.PENDING_SNAPSHOT_UNCERTAIN_FAILS)
+            fail_threshold = max(1, fail_threshold)
+
+            try:
+                ttl_seconds = float(ttl_cfg)
+            except Exception:
+                ttl_seconds = float(self.PENDING_SNAPSHOT_UNCERTAIN_TTL_SECONDS)
+            ttl_seconds = max(0.0, ttl_seconds)
+
+            if self._pending_snapshot_fail_count >= fail_threshold:
+                prev_until = float(getattr(self, '_uncertain_mode_until', 0.0) or 0.0)
+                self._uncertain_mode_until = max(prev_until, now_ts + ttl_seconds)
+                if prev_until <= now_ts:
+                    print(
+                        f"[Broker Safety] Entered uncertain mode for {ttl_seconds:.1f}s "
+                        f"(pending snapshot unstable, reason={reason})."
+                    )
+
+    def is_uncertain_mode(self):
+        until = float(getattr(self, '_uncertain_mode_until', 0.0) or 0.0)
+        return until > time.time()
+
+    def _queue_uncertain_buy_retry(self, retry_func, data, target, **kwargs):
+        """
+        不确定模式下，买单只排队不执行。
+        这是有意设计：夜间无人值守时优先“防扩大亏损”，而不是“追求信号不丢失”。
+        """
+        retry_kwargs = {'data': data, 'target': target}
+        retry_kwargs.update(kwargs)
+        symbol = getattr(data, '_name', 'Unknown')
+        func_name = getattr(retry_func, '__name__', '')
+
+        with self._ledger_lock:
+            replaced = False
+            for item in self._deferred_orders:
+                if not isinstance(item, dict):
+                    continue
+                item_func = item.get('func')
+                item_kwargs = item.get('kwargs') or {}
+                queued_data = item_kwargs.get('data')
+                queued_symbol = getattr(queued_data, '_name', None)
+                if getattr(item_func, '__name__', '') == func_name and queued_symbol == symbol:
+                    # 只保留同 symbol 的最新目标，避免队列膨胀和陈旧目标重放。
+                    item['kwargs'] = retry_kwargs
+                    item['updated_at'] = time.time()
+                    replaced = True
+                    break
+
+        if not replaced:
+            self._add_deferred(retry_func, retry_kwargs)
+            print(f"[Broker Safety] BUY {symbol} deferred (uncertain mode).")
+        else:
+            print(f"[Broker Safety] BUY {symbol} deferred target refreshed (uncertain mode).")
+        return _DeferredOrderProxy(data)
+
+    def _fetch_pending_orders_with_retry(self, reason="unknown"):
+        """
+        轻量重试获取在途快照，吸收短暂网络抖动。
+        失败时抛出原始异常，由上层选择保守/降级行为。
+        """
+        attempts_cfg = getattr(config, 'BROKER_PENDING_SNAPSHOT_RETRY_ATTEMPTS', self.PENDING_SNAPSHOT_RETRY_ATTEMPTS)
+        sleep_cfg = getattr(config, 'BROKER_PENDING_SNAPSHOT_RETRY_SLEEP_SECONDS', self.PENDING_SNAPSHOT_RETRY_SLEEP_SECONDS)
+
+        try:
+            attempts = int(attempts_cfg)
+        except Exception:
+            attempts = int(self.PENDING_SNAPSHOT_RETRY_ATTEMPTS)
+        attempts = max(1, attempts)
+
+        try:
+            sleep_s = float(sleep_cfg)
+        except Exception:
+            sleep_s = float(self.PENDING_SNAPSHOT_RETRY_SLEEP_SECONDS)
+        sleep_s = max(0.0, sleep_s)
+
+        last_exc = None
+        for idx in range(attempts):
+            try:
+                pending_orders = self.get_pending_orders()
+                self._mark_pending_snapshot_success()
+                if pending_orders is None:
+                    return []
+                if isinstance(pending_orders, list):
+                    return pending_orders
+                return list(pending_orders)
+            except Exception as e:
+                last_exc = e
+                if idx + 1 < attempts:
+                    if idx == 0:
+                        print(f"[Broker Heal] Pending snapshot query failed ({reason}), retrying...")
+                    if sleep_s > 0:
+                        time.sleep(sleep_s)
+                    continue
+                break
+        if last_exc is not None:
+            self._mark_pending_snapshot_failure(reason=reason)
+            raise last_exc
+        return []
+
     def _recalc_rejected_buy_shares(self, old_shares, price, lot_size):
         """
         买单拒绝后按当前可用资金重算可下单数量。
@@ -394,28 +690,605 @@ class BaseLiveBroker(ABC):
         recalc_shares = min(recalc_shares, upper_bound)
         return max(0, recalc_shares)
 
-    def _is_order_still_pending(self, order_id):
+    def _is_order_still_pending(self, order_id, symbol=None, side=None, pending_orders=None, snapshot_unavailable=False):
         """
         检查订单是否仍在柜台在途。
-        若在途列表不含 id 字段，则返回 False（不阻塞重试）。
+        优先按订单 id 精准匹配；
+        若券商不返回 id（例如部分 API），则降级按 symbol + side 粗匹配。
+        返回值:
+        - True: 明确仍在途
+        - False: 明确不在途
+        - None: 在途快照不可用（查询异常）
         """
-        if not order_id:
+        if not order_id and not symbol:
             return False
+        if pending_orders is None and not snapshot_unavailable:
+            try:
+                pending_orders = self._fetch_pending_orders_with_retry(reason="is_order_still_pending")
+            except Exception:
+                memory_state = self._pending_state_from_memory(order_id, symbol=symbol, side=side)
+                if memory_state is not None:
+                    return memory_state
+                return None
+        elif snapshot_unavailable:
+            memory_state = self._pending_state_from_memory(order_id, symbol=symbol, side=side)
+            if memory_state is not None:
+                return memory_state
+            return None
+
+        found_id_field = False
+        symbol_matched_without_id = False
+        oid = str(order_id) if order_id else ''
+        sym_norm = str(symbol).upper() if symbol else ''
+        side_norm = str(side).upper() if side else ''
+
+        for po in pending_orders or []:
+            if not isinstance(po, dict):
+                continue
+            direction = str(po.get('direction', '')).upper()
+            if side_norm and direction and direction != side_norm:
+                continue
+
+            poid = po.get('id')
+            if poid is not None and str(poid).strip():
+                found_id_field = True
+                if oid and str(poid) == oid:
+                    return True
+                continue
+
+            if sym_norm:
+                po_sym = str(po.get('symbol', '')).upper()
+                if po_sym == sym_norm or po_sym == sym_norm.split('.')[0]:
+                    symbol_matched_without_id = True
+
+        if symbol_matched_without_id:
+            # 混合快照（部分订单有 id、部分无 id）时，仍允许 symbol 级保守兜底，
+            # 避免因返回顺序导致“误判不在途”而提前释放缓冲重试。
+            return True
+
+        if found_id_field:
+            return False
+        return False
+
+    def _reconcile_pending_sells_from_broker(self, pending_orders=None, snapshot_error=None):
+        """
+        与柜台在途订单对账 _pending_sells，修复回调缺失导致的本地状态漂移。
+        要求调用方已持有 _ledger_lock。
+        """
+        # 快照明确不可用时保持保守，不在持锁路径重复打网络。
+        if snapshot_error is not None and pending_orders is None:
+            return 0
+        if pending_orders is None:
+            try:
+                pending_orders = self._fetch_pending_orders_with_retry(reason="reconcile_pending_sells")
+            except Exception:
+                return 0
+
+        live_sell_orders = []
+        live_sell_ids = set()
+        for po in pending_orders or []:
+            if not isinstance(po, dict):
+                continue
+            direction = str(po.get('direction', '')).upper()
+            if direction != 'SELL':
+                continue
+            try:
+                remain = float(po.get('size', 0) or 0)
+            except Exception:
+                remain = 0.0
+            if remain <= 0:
+                continue
+            live_sell_orders.append(po)
+            poid = po.get('id')
+            if poid is None or str(poid).strip() == '':
+                continue
+            live_sell_ids.add(str(poid))
+
+        # 情况 A: 柜台快照显示当前无任何 SELL 在途
+        # 采用“连续空快照 + 最短等待时长”再清理，降低网络抖动误判概率。
+        if not live_sell_orders:
+            if not self._pending_sells:
+                self._pending_sell_empty_snapshots = 0
+                self._pending_sell_empty_since = None
+                return 0
+
+            self._pending_sell_empty_snapshots = int(getattr(self, '_pending_sell_empty_snapshots', 0)) + 1
+            if self._pending_sell_empty_since is None:
+                self._pending_sell_empty_since = time.time()
+            clear_threshold = int(
+                getattr(config, 'BROKER_PENDING_SELL_CLEAR_EMPTY_SNAPSHOTS', 2) or 2
+            )
+            clear_threshold = max(1, clear_threshold)
+            min_wait_cfg = getattr(
+                config,
+                'BROKER_PENDING_SELL_CLEAR_EMPTY_SECONDS',
+                self.PENDING_SELL_CLEAR_EMPTY_MIN_SECONDS
+            )
+            try:
+                min_wait_seconds = float(min_wait_cfg)
+            except Exception:
+                min_wait_seconds = float(self.PENDING_SELL_CLEAR_EMPTY_MIN_SECONDS)
+            min_wait_seconds = max(0.0, min_wait_seconds)
+            waited = max(0.0, time.time() - float(self._pending_sell_empty_since or time.time()))
+
+            if (
+                self._pending_sells
+                and self._pending_sell_empty_snapshots >= clear_threshold
+                and waited >= min_wait_seconds
+            ):
+                stale_cnt = len(self._pending_sells)
+                self._pending_sells.clear()
+                self._pending_sell_empty_snapshots = 0
+                self._pending_sell_empty_since = None
+                print(f"[Broker Heal] Cleared {stale_cnt} stale pending-sell markers (broker snapshot empty).")
+                return stale_cnt
+            return 0
+
+        # 只要看到真实 SELL 在途，空快照计数归零
+        self._pending_sell_empty_snapshots = 0
+        self._pending_sell_empty_since = None
+
+        # 情况 B: 柜台有 SELL 在途，但不提供 id，无法做精确集合对账
+        if not live_sell_ids:
+            return 0
+
+        removed = self._pending_sells - live_sell_ids
+        added = live_sell_ids - self._pending_sells
+        if removed:
+            self._pending_sells -= removed
+            print(f"[Broker Heal] Cleared {len(removed)} stale pending-sell markers.")
+        if added:
+            self._pending_sells |= added
+            print(f"[Broker Heal] Synced {len(added)} pending-sell markers from broker snapshot.")
+        return len(removed) + len(added)
+
+    def _reconcile_active_buys_from_broker(self, pending_orders=None, snapshot_error=None):
+        """
+        与柜台在途 BUY 快照对账 _active_buys，修复回调缺失导致的幽灵占资。
+        要求调用方已持有 _ledger_lock。
+        """
+        if not self._active_buys:
+            self._active_buy_empty_snapshots = 0
+            self._active_buy_empty_since = None
+            return 0
+
+        # 快照明确不可用时保持保守，不在持锁路径重复打网络。
+        if snapshot_error is not None and pending_orders is None:
+            return 0
+        if pending_orders is None:
+            try:
+                pending_orders = self._fetch_pending_orders_with_retry(reason="reconcile_active_buys")
+            except Exception:
+                return 0
+
+        live_buy_ids = set()
+        live_buy_symbols = set()
+        for po in pending_orders or []:
+            if not isinstance(po, dict):
+                continue
+            direction = str(po.get('direction', '')).upper()
+            if direction != 'BUY':
+                continue
+            try:
+                remain = float(po.get('size', 0) or 0)
+            except Exception:
+                remain = 0.0
+            if remain <= 0:
+                continue
+            poid = po.get('id')
+            if poid is not None and str(poid).strip():
+                live_buy_ids.add(str(poid))
+            po_symbol = str(po.get('symbol', '')).upper().strip()
+            if po_symbol:
+                live_buy_symbols.add(po_symbol)
+                live_buy_symbols.add(po_symbol.split('.')[0])
+        has_live_buy_ids = bool(live_buy_ids)
+
+        now_ts = time.time()
+        clear_threshold = int(
+            getattr(config, 'BROKER_ACTIVE_BUY_CLEAR_EMPTY_SNAPSHOTS', 2) or 2
+        )
+        clear_threshold = max(1, clear_threshold)
+        min_wait_cfg = getattr(
+            config,
+            'BROKER_ACTIVE_BUY_CLEAR_EMPTY_SECONDS',
+            self.ACTIVE_BUY_CLEAR_EMPTY_MIN_SECONDS
+        )
         try:
-            pending_orders = self.get_pending_orders()
+            min_wait_seconds = float(min_wait_cfg)
         except Exception:
+            min_wait_seconds = float(self.ACTIVE_BUY_CLEAR_EMPTY_MIN_SECONDS)
+        min_wait_seconds = max(0.0, min_wait_seconds)
+
+        stale_keys = []
+        stale_items = []
+        for oid, info in list(self._active_buys.items()):
+            if not isinstance(info, dict):
+                continue
+
+            symbol_name = getattr(info.get('data'), '_name', '') if info.get('data') is not None else ''
+            symbol_norm = str(symbol_name).upper() if symbol_name else ''
+            symbol_short = symbol_norm.split('.')[0] if symbol_norm else ''
+
+            seen_on_broker = False
+            if str(oid) in live_buy_ids:
+                seen_on_broker = True
+            elif (not has_live_buy_ids) and symbol_norm and (symbol_norm in live_buy_symbols or symbol_short in live_buy_symbols):
+                seen_on_broker = True
+
+            if seen_on_broker:
+                info.pop('miss_snapshots', None)
+                info.pop('miss_since', None)
+                continue
+
+            miss = int(info.get('miss_snapshots', 0) or 0) + 1
+            info['miss_snapshots'] = miss
+            if info.get('miss_since') is None:
+                info['miss_since'] = now_ts
+            miss_waited = max(0.0, now_ts - float(info.get('miss_since') or now_ts))
+            created_at = float(info.get('created_at', now_ts) or now_ts)
+            age = max(0.0, now_ts - created_at)
+
+            # 双条件释放：连续缺失且订单已存在足够时间。
+            if miss < clear_threshold or age < min_wait_seconds:
+                continue
+            if miss_waited < min_wait_seconds:
+                continue
+
+            stale_keys.append(str(oid))
+            stale_items.append(info)
+
+        if not stale_keys:
+            return 0
+
+        release_amount = 0.0
+        for info in stale_items:
+            try:
+                release_amount += (
+                    float(info.get('shares', 0) or 0)
+                    * float(info.get('price', 0) or 0)
+                    * self.safety_multiplier
+                )
+            except Exception:
+                continue
+        for oid in stale_keys:
+            self._active_buys.pop(oid, None)
+        self._active_buy_empty_snapshots = 0
+        self._active_buy_empty_since = None
+        if release_amount > 0:
+            self._virtual_spent_cash = max(
+                0.0,
+                getattr(self, '_virtual_spent_cash', 0.0) - release_amount
+            )
+        stale_cnt = len(stale_keys)
+        print(
+            f"[Broker Heal] Cleared {stale_cnt} stale active-buy trackers "
+            f"(broker BUY snapshot mismatch). Released virtual cash: {release_amount:.2f}"
+        )
+        return stale_cnt
+
+    def _drain_buffered_rejected_retries(self, reason="unknown", pending_orders=None, snapshot_error=None):
+        """
+        尝试释放已不在途的“拒单缓冲重试”。
+        要求调用方已持有 _ledger_lock。
+        """
+        if not self._buffered_rejected_retries:
+            return 0
+
+        snapshot_unavailable = snapshot_error is not None
+        if pending_orders is None and not snapshot_unavailable:
+            lock_owned = False
+            if hasattr(self._ledger_lock, '_is_owned'):
+                try:
+                    lock_owned = bool(self._ledger_lock._is_owned())
+                except Exception:
+                    lock_owned = False
+
+            # 在已持锁路径下避免发起网络查询，防止把回调线程一并堵住。
+            if lock_owned:
+                snapshot_unavailable = True
+                now_ts = time.time()
+                if now_ts - float(getattr(self, '_last_buffered_snapshot_skip_log_ts', 0.0) or 0.0) >= 10.0:
+                    self._last_buffered_snapshot_skip_log_ts = now_ts
+                    print(f"[Broker Heal] Skip buffered retry snapshot query while lock is held (reason={reason}).")
+                return 0
+            else:
+                try:
+                    pending_orders = self._fetch_pending_orders_with_retry(reason=f"drain_buffered:{reason}")
+                except Exception as e:
+                    snapshot_unavailable = True
+                    snapshot_error = e
+
+        max_wait = float(self.BUFFERED_RETRY_WARN_SECONDS)
+        drained = 0
+        now_ts = time.time()
+        keys = list(self._buffered_rejected_retries.keys())
+        for key in keys:
+            payload = self._buffered_rejected_retries.get(key)
+            if not payload:
+                continue
+            symbol = payload.get('symbol')
+            pending_state = self._is_order_still_pending(
+                key,
+                symbol=symbol,
+                side='BUY',
+                pending_orders=pending_orders,
+                snapshot_unavailable=snapshot_unavailable,
+            )
+
+            if pending_state is None:
+                fail_count = int(payload.get('pending_query_fail_count', 0)) + 1
+                payload['pending_query_fail_count'] = fail_count
+                fail_since = payload.get('pending_query_fail_since')
+                if fail_since is None:
+                    fail_since = now_ts
+                    payload['pending_query_fail_since'] = fail_since
+                fail_waited = max(0.0, now_ts - float(fail_since))
+
+                if not payload.get('warned_query_unavailable'):
+                    payload['warned_query_unavailable'] = True
+                    print(
+                        f"[Broker Heal] Pending snapshot unavailable for buffered retry "
+                        f"{symbol or 'Unknown'} (reason={reason}). Waiting..."
+                    )
+                elif fail_count % 10 == 0:
+                    print(
+                        f"[Broker Heal] Pending snapshot still unavailable for buffered retry "
+                        f"{symbol or 'Unknown'} (count={fail_count}, waited={fail_waited:.1f}s). Keeping buffered."
+                    )
+                continue
+
+            if pending_state:
+                payload.pop('pending_query_fail_count', None)
+                payload.pop('pending_query_fail_since', None)
+                payload.pop('warned_query_unavailable', None)
+                queued_at = payload.get('queued_at')
+                if queued_at is not None:
+                    waited = max(0.0, now_ts - float(queued_at))
+                    # 超时仅告警，不强行重提，避免真实在途单被重复占资。
+                    if waited > max_wait and not payload.get('warned_timeout'):
+                        payload['warned_timeout'] = True
+                        print(
+                            f"[Broker Heal] Buffered retry for {symbol or 'Unknown'} waiting {waited:.1f}s "
+                            f"(reason={reason}), still pending on broker."
+                        )
+                continue
+
+            # 安全策略：不确定模式下默认不释放 BUY 重试，避免在快照不稳定时增加敞口。
+            # 例外：已在本地状态记忆中明确看到终态，释放属于“解卡死”，不是“盲目加仓”。
+            state_item = self._order_state_memory.get(str(key), {})
+            known_terminal = isinstance(state_item, dict) and bool(state_item.get('terminal'))
+            if self.is_uncertain_mode() and not known_terminal:
+                if not payload.get('warned_uncertain_mode'):
+                    payload['warned_uncertain_mode'] = True
+                    print(f"[Broker Safety] Buffered retry for {symbol or 'Unknown'} paused in uncertain mode.")
+                continue
+            payload.pop('warned_uncertain_mode', None)
+            self._submit_buffered_rejected_retry(key)
+            drained += 1
+
+        return drained
+
+    def has_deferred_orders(self):
+        with self._ledger_lock:
+            return bool(self._deferred_orders)
+
+    def has_runtime_backlog(self):
+        with self._ledger_lock:
+            return bool(
+                self._deferred_orders
+                or self._pending_sells
+                or self._active_buys
+                or self._buffered_rejected_retries
+            )
+
+    def has_pending_order(self, symbol, side=None):
+        """
+        通用在途订单查询（按 symbol + side）。
+        返回值:
+        - True: 明确在途
+        - False: 明确不在途
+        - None: 快照不可用
+        """
+        if not symbol:
             return False
+        side_norm = str(side).upper() if side else ''
+        symbol_norm = str(symbol).upper()
+        try:
+            pending_orders = self._fetch_pending_orders_with_retry(reason="has_pending_order")
+        except Exception:
+            return None
 
-        found_id_field = False
-        oid = str(order_id)
         for po in pending_orders or []:
-            poid = po.get('id') if isinstance(po, dict) else None
-            if poid is None:
+            if not isinstance(po, dict):
                 continue
-            found_id_field = True
-            if str(poid) == oid:
+            direction = str(po.get('direction', '')).upper()
+            if side_norm and direction and direction != side_norm:
+                continue
+            po_symbol = str(po.get('symbol', '')).upper()
+            if po_symbol != symbol_norm and po_symbol != symbol_norm.split('.')[0]:
+                continue
+            try:
+                if float(po.get('size', 0) or 0) <= 0:
+                    continue
+            except Exception:
+                pass
+            return True
+        return False
+
+    def _pick_deferred_symbol(self):
+        with self._ledger_lock:
+            for item in self._deferred_orders:
+                if not isinstance(item, dict):
+                    continue
+                kwargs = item.get('kwargs') or {}
+                data = kwargs.get('data')
+                name = getattr(data, '_name', None)
+                if name:
+                    return str(name)
+        return None
+
+    @staticmethod
+    def _snapshot_has_pending_sell(pending_orders):
+        for po in pending_orders or []:
+            if not isinstance(po, dict):
+                continue
+            if str(po.get('direction', '')).upper() != 'SELL':
+                continue
+            try:
+                if float(po.get('size', 0) or 0) <= 0:
+                    continue
+            except Exception:
                 return True
-        return False if found_id_field else False
+            return True
+        return False
+
+    def _can_replay_deferred(self, reason="unknown", pending_orders=None, snapshot_error=None):
+        # 不确定模式或快照不可用时，禁止新增 BUY 风险。
+        if self.is_uncertain_mode():
+            return False
+
+        if pending_orders is not None:
+            has_pending_sell = self._snapshot_has_pending_sell(pending_orders)
+        elif snapshot_error is not None:
+            return False
+        else:
+            has_pending_sell = self._has_pending_sells()
+
+        # 本地 pending-sell 标记是额外保守闸门，防止单次假空快照提前重放。
+        with self._ledger_lock:
+            if self._pending_sells:
+                has_pending_sell = True
+
+        return not has_pending_sell
+
+    def _reconcile_strategy_deferred_virtual_order(self, now_ts):
+        """
+        主动回收策略层 DEFERRED_VIRTUAL_ID，避免 schedule 低频下仅依赖下一次 run 才解锁。
+        要求调用方已持有 _ledger_lock。
+        """
+        ctx = getattr(self, '_context', None)
+        strategy = getattr(ctx, 'strategy_instance', None) if ctx else None
+        if strategy is None:
+            self._strategy_deferred_empty_since = None
+            return 0
+
+        order = getattr(strategy, 'order', None)
+        if not order or getattr(order, 'id', None) != "DEFERRED_VIRTUAL_ID":
+            self._strategy_deferred_empty_since = None
+            return 0
+
+        has_backlog = bool(
+            self._deferred_orders
+            or self._pending_sells
+            or self._active_buys
+            or self._buffered_rejected_retries
+        )
+        if has_backlog:
+            self._strategy_deferred_empty_since = None
+            return 0
+
+        if self._strategy_deferred_empty_since is None:
+            self._strategy_deferred_empty_since = now_ts
+            return 0
+
+        grace_cfg = getattr(config, 'BROKER_DEFERRED_CLEAR_GRACE_SECONDS', 5.0)
+        try:
+            grace = float(grace_cfg)
+        except Exception:
+            grace = 5.0
+        grace = max(0.0, grace)
+        waited = max(0.0, now_ts - float(self._strategy_deferred_empty_since))
+        if waited < grace:
+            return 0
+
+        strategy.order = None
+        self._strategy_deferred_empty_since = None
+        print(f"[Broker Heal] Cleared stale strategy deferred placeholder after {waited:.1f}s.")
+        return 1
+
+    def self_heal(self, reason="heartbeat", force=False):
+        """
+        轻量自愈入口：
+        - 对账 _pending_sells
+        - 尝试释放可执行的拒单缓冲重试
+        """
+        now_ts = time.time()
+        min_interval = float(self.SELF_HEAL_MIN_INTERVAL_SECONDS)
+        pending_orders = None
+        pending_snapshot_error = None
+        with self._ledger_lock:
+            if not force and now_ts - self._last_self_heal_ts < min_interval:
+                return 0
+            self._last_self_heal_ts = now_ts
+
+        # 网络快照查询放到锁外，避免把订单回调和主循环一并阻塞。
+        try:
+            pending_orders = self._fetch_pending_orders_with_retry(reason=f"self_heal:{reason}")
+        except Exception as e:
+            pending_snapshot_error = e
+
+        with self._ledger_lock:
+            changed = 0
+            changed += self._reconcile_pending_sells_from_broker(
+                pending_orders=pending_orders,
+                snapshot_error=pending_snapshot_error,
+            )
+            changed += self._reconcile_active_buys_from_broker(
+                pending_orders=pending_orders,
+                snapshot_error=pending_snapshot_error,
+            )
+            changed += self._drain_buffered_rejected_retries(
+                reason=reason,
+                pending_orders=pending_orders,
+                snapshot_error=pending_snapshot_error,
+            )
+            changed += self._reconcile_strategy_deferred_virtual_order(now_ts)
+
+        should_replay = (
+            self.has_deferred_orders()
+            and self._can_replay_deferred(
+                reason=reason,
+                pending_orders=pending_orders,
+                snapshot_error=pending_snapshot_error,
+            )
+        )
+        if should_replay:
+            replay_min_interval = float(self.DEFERRED_REPLAY_INTERVAL_SECONDS)
+            if now_ts - float(getattr(self, '_last_deferred_replay_ts', 0.0)) >= replay_min_interval:
+                self._last_deferred_replay_ts = now_ts
+                print(f"[Broker Heal] No pending sells. Replaying deferred orders (reason={reason}).")
+                try:
+                    self.process_deferred_orders(assume_sell_cleared=True)
+                    changed += 1
+                except Exception as e:
+                    print(f"[Broker Heal] Warning: deferred replay failed in self_heal: {e}")
+        elif self.has_deferred_orders() and self.is_uncertain_mode():
+            warn_interval = float(getattr(config, 'BROKER_UNCERTAIN_REPLAY_LOG_INTERVAL_SECONDS', 30.0) or 30.0)
+            last_warn_ts = float(getattr(self, '_last_uncertain_replay_skip_log_ts', 0.0) or 0.0)
+            if now_ts - last_warn_ts >= max(1.0, warn_interval):
+                self._last_uncertain_replay_skip_log_ts = now_ts
+                print("[Broker Safety] Deferred replay paused: uncertain mode active.")
+        return changed
+
+    def on_sell_filled(self):
+        """
+        卖单成交后的统一后处理入口（去耦 engine 回调逻辑）。
+        """
+        print("[Broker] Sell filled hook: syncing balance and validating sell-clear before deferred replay...")
+        try:
+            self.sync_balance()
+            print(f"[Broker] Cash after sync: {self.get_cash():.2f}")
+        except Exception as e:
+            print(f"[Broker] Warning: sync_balance failed after sell fill: {e}")
+
+        try:
+            # 统一通过 self_heal 进行“卖单是否出清”的确认与重放闸门决策。
+            self.self_heal(reason="sell_filled", force=True)
+        except Exception as e:
+            print(f"[Broker] Warning: self_heal failed after sell fill: {e}")
+
+        return None
 
     def _submit_buffered_rejected_retry(self, source_oid):
         """
@@ -489,7 +1362,8 @@ class BaseLiveBroker(ABC):
                         'shares': final_submitted_shares,
                         'price': price,
                         'lot_size': lot_size,
-                        'retries': retries
+                        'retries': retries,
+                        'created_at': time.time(),
                     }
             return proxy
         return None
@@ -522,131 +1396,157 @@ class BaseLiveBroker(ABC):
             return proxy
         return None
 
+    def _pop_buy_and_refund_virtual_cash(self, oid, proxy):
+        """
+        从活跃买单表弹出并回退对应虚拟占资。
+        要求调用方已持有 _ledger_lock。
+        返回 (buy_info, symbol, refund_amount) 或 None。
+        """
+        buy_info = self._active_buys.pop(oid, None)
+        if not buy_info:
+            return None
+
+        refund_amount = (
+            float(buy_info.get('shares', 0) or 0)
+            * float(buy_info.get('price', 0) or 0)
+            * self.safety_multiplier
+        )
+        symbol = (
+            getattr(buy_info.get('data'), '_name', None)
+            or getattr(getattr(proxy, 'data', None), '_name', 'Unknown')
+        )
+        self._virtual_spent_cash = max(
+            0.0,
+            float(getattr(self, '_virtual_spent_cash', 0.0) or 0.0) - refund_amount
+        )
+        return buy_info, symbol, refund_amount
+
     def on_order_status(self, proxy: BaseOrderProxy):
         """由 Engine 回调，自动维护在途单状态与降级重试"""
         oid = proxy.id
+        proxy_symbol = self._resolve_proxy_symbol(proxy)
+        drain_reason = None
 
         # 整个回调必须排队，防止抢占主线程刚发出的订单
         with self._ledger_lock:
+            # 先记录状态快照，供后续快照失败时做安全回退判定
+            self._remember_order_state(proxy)
             # ==========================================
             # 1. 买单异步降级逻辑 (Buy Order Downgrade)
             # ==========================================
             if proxy.is_buy():
                 if proxy.is_completed():
                     # 买单终态(Filled): 物理现金已结算，必须回退本地虚拟预扣，避免双重扣减可用资金
-                    buy_info = self._active_buys.pop(oid, None)
-                    if buy_info:
-                        refund_amount = buy_info['shares'] * buy_info['price'] * self.safety_multiplier
-                        symbol = getattr(buy_info.get('data'), '_name', None) or getattr(getattr(proxy, 'data', None), '_name', 'Unknown')
-                        self._virtual_spent_cash = max(
-                            0.0,
-                            getattr(self, '_virtual_spent_cash', 0.0) - refund_amount
-                        )
+                    released = self._pop_buy_and_refund_virtual_cash(oid, proxy)
+                    if released:
+                        _, symbol, refund_amount = released
                         print(f"[Broker] ✅ 买单 {symbol} 已成交。已释放虚拟扣款: {refund_amount:.2f}")
 
                 elif proxy.is_canceled():
                     # 撤单防御：精准回退被冻结的虚拟预扣资金（不触发降级重试）
-                    with self._ledger_lock:
-                        buy_info = self._active_buys.pop(oid, None)
-                        if buy_info:
-                            refund_amount = buy_info['shares'] * buy_info['price'] * self.safety_multiplier
-                            symbol = getattr(buy_info.get('data'), '_name', None) or getattr(getattr(proxy, 'data', None), '_name', 'Unknown')
-                            self._virtual_spent_cash = max(
-                                0.0,
-                                getattr(self, '_virtual_spent_cash', 0.0) - refund_amount
-                            )
-                            print(f"[Broker] ⚠️ 买单 {symbol} 被撤销。已回退虚拟扣款: {refund_amount:.2f}")
-                        self._submit_buffered_rejected_retry(oid)
+                    released = self._pop_buy_and_refund_virtual_cash(oid, proxy)
+                    if released:
+                        _, symbol, refund_amount = released
+                        print(f"[Broker] ⚠️ 买单 {symbol} 被撤销。已回退虚拟扣款: {refund_amount:.2f}")
+                    self._submit_buffered_rejected_retry(oid)
 
                 elif proxy.is_rejected():
-                    with self._ledger_lock:
-                        buy_info = self._active_buys.pop(oid, None)
-                        if buy_info:
-                            retries = buy_info['retries']
-                            max_retries = 3  # 默认允许尝试降级 3 次
-
-                            # A. 退回上一笔订单预扣的虚拟资金 (使用动态滑点)
-                            refund_amount = buy_info['shares'] * buy_info['price'] * self.safety_multiplier
-                            self._virtual_spent_cash = max(0.0, getattr(self, '_virtual_spent_cash', 0.0) - refund_amount)
-
-                            # B. 检查是否还有重试机会
-                            if retries < max_retries:
-                                lot_size = buy_info['lot_size']
-                                data = buy_info['data']
-                                symbol = getattr(data, '_name', None) or getattr(getattr(proxy, 'data', None), '_name', 'Unknown')
-                                price = buy_info['price']
-
-                                # 优先按当前可用资金重算；失败时再走逐手降级兜底。
-                                old_shares = buy_info['shares']
-                                recalculated = self._recalc_rejected_buy_shares(old_shares, price, lot_size)
-                                if recalculated > 0:
-                                    new_shares = recalculated
-                                    downgrade_reason = "资金重算"
+                    released = self._pop_buy_and_refund_virtual_cash(oid, proxy)
+                    if released:
+                        buy_info, _, _ = released
+                        retries = int(buy_info.get('retries', 0) or 0)
+                        max_retries = 3  # 默认允许尝试降级 3 次
+
+                        # B. 检查是否还有重试机会
+                        if retries < max_retries:
+                            lot_size = int(buy_info.get('lot_size', 1) or 1)
+                            data = buy_info.get('data')
+                            symbol = getattr(data, '_name', None) or getattr(getattr(proxy, 'data', None), '_name', 'Unknown')
+                            price = float(buy_info.get('price', 0) or 0)
+
+                            # 优先按当前可用资金重算；失败时再走逐手降级兜底。
+                            old_shares = int(buy_info.get('shares', 0) or 0)
+                            recalculated = self._recalc_rejected_buy_shares(old_shares, price, lot_size)
+                            if recalculated > 0:
+                                new_shares = recalculated
+                                downgrade_reason = "资金重算"
+                            else:
+                                new_shares = old_shares - lot_size
+                                downgrade_reason = "逐手降级"
+
+                            print(f"⚠️ [Broker] 买单 {symbol} 被拒绝。触发自动降级 {retries + 1}/{max_retries}...")
+                            print(f"   => {symbol} 尝试数量: {old_shares} -> {new_shares} ({downgrade_reason})")
+
+                            if new_shares > 0:
+                                # 回调路径只做缓冲，释放由锁外对账完成，避免持锁网络查询阻塞主循环。
+                                key = str(oid)
+                                if key not in self._buffered_rejected_retries:
+                                    self._buffered_rejected_retries[key] = {
+                                        'data': data,
+                                        'symbol': symbol,
+                                        'new_shares': new_shares,
+                                        'price': price,
+                                        'lot_size': lot_size,
+                                        'next_retries': retries + 1,
+                                        'queued_at': time.time(),
+                                    }
+                                    print(f"[Broker] ⏳ {symbol} 原单状态待确认，缓冲降级重试等待释放。")
                                 else:
-                                    new_shares = old_shares - lot_size
-                                    downgrade_reason = "逐手降级"
-
-                                print(f"⚠️ [Broker] 买单 {symbol} 被拒绝。触发自动降级 {retries + 1}/{max_retries}...")
-                                print(f"   => {symbol} 尝试数量: {old_shares} -> {new_shares} ({downgrade_reason})")
-
-                                if new_shares > 0:
-                                    # 柜台订单仍在途时，先缓冲，等待 Cancelled/终态后再重试，避免“旧单+新单”叠加占资。
-                                    if self._is_order_still_pending(oid):
-                                        key = str(oid)
-                                        if key not in self._buffered_rejected_retries:
-                                            self._buffered_rejected_retries[key] = {
-                                                'data': data,
-                                                'symbol': symbol,
-                                                'new_shares': new_shares,
-                                                'price': price,
-                                                'lot_size': lot_size,
-                                                'next_retries': retries + 1,
-                                                'queued_at': time.time(),
-                                            }
-                                            print(f"[Broker] ⏳ 原单 {oid} 仍在途，缓冲降级重试，等待终态后提交。")
-                                        else:
-                                            print(f"[Broker] ⏳ 原单 {oid} 的缓冲重试已存在，忽略重复拒单回调。")
-                                    else:
-                                        # 原单已出清，可立即执行降级重试。
-                                        deduct_amount = new_shares * price * self.safety_multiplier
-                                        self._virtual_spent_cash += deduct_amount
-
-                                        new_proxy = self._finalize_and_submit(data, new_shares, price, lot_size,
-                                                                              retries + 1)
-
-                                        # 如果同步发单失败(比如断网)，必须把预扣的钱退回来
-                                        if not new_proxy:
-                                            self._virtual_spent_cash = max(
-                                                0.0,
-                                                getattr(self, '_virtual_spent_cash', 0.0) - deduct_amount
-                                            )
-                                            print(f"❌ [Broker] 降级发单同步失败，资金已回退。")
-                                else:
-                                    print(f"❌ [Broker] 降级终止: {data._name} 数量已降至 0。")
-                return
+                                    print(f"[Broker] ⏳ {symbol} 缓冲重试已存在，忽略重复拒单回调。")
+                            else:
+                                print(f"❌ [Broker] 降级终止: {symbol} 数量已降至 0。")
+                    else:
+                        # 兜底：某些柜台会重复推 Rejected/Inactive，但不再推 Canceled。
+                        # 这里仅记录等待，实际释放由锁外快照对账统一执行。
+                        key = str(oid)
+                        if key in self._buffered_rejected_retries:
+                            buffered_symbol = self._buffered_rejected_retries.get(key, {}).get('symbol') or proxy_symbol
+                            print(f"[Broker] ⏳ {buffered_symbol} 缓冲降级重试待锁外对账释放。")
+                drain_reason = f"buy_callback:{proxy_symbol}"
+            elif proxy.is_sell():
+                # ==========================================
+                # 2. 卖单在途维护逻辑 (Sell Order Pending)
+                # ==========================================
+                if proxy.is_completed():
+                    self._pending_sells.discard(oid)
+
+                elif proxy.is_canceled() or proxy.is_rejected():
+                    self._pending_sells.discard(oid)
+                    if self._deferred_orders:
+                        print(
+                            f"[Broker] WARNING: Sell {proxy_symbol} failed. Cancelling {len(self._deferred_orders)} deferred buy orders.")
+                        self._deferred_orders.clear()
+                elif proxy.is_pending():
+                    self._pending_sells.add(oid)
+                drain_reason = f"sell_callback:{proxy_symbol}"
+
+        if not drain_reason:
+            return
 
-            # ==========================================
-            # 2. 卖单在途维护逻辑 (Sell Order Pending)
-            # ==========================================
-            if not proxy.is_sell(): return
+        with self._ledger_lock:
+            has_buffered = bool(self._buffered_rejected_retries)
+        if not has_buffered:
+            return
 
-            if proxy.is_completed():
-                self._pending_sells.discard(oid)
+        pending_orders = None
+        pending_snapshot_error = None
+        try:
+            pending_orders = self._fetch_pending_orders_with_retry(reason=f"order_callback_drain:{proxy_symbol}")
+        except Exception as e:
+            pending_snapshot_error = e
 
-            elif proxy.is_canceled() or proxy.is_rejected():
-                self._pending_sells.discard(oid)
-                if self._deferred_orders:
-                    print(
-                        f"[Broker] WARNING: Sell order {oid} failed. Cancelling {len(self._deferred_orders)} deferred buy orders.")
-                    self._deferred_orders.clear()
-            elif proxy.is_pending():
-                self._pending_sells.add(oid)
+        with self._ledger_lock:
+            self._drain_buffered_rejected_retries(
+                reason=drain_reason,
+                pending_orders=pending_orders,
+                snapshot_error=pending_snapshot_error,
+            )
 
     def get_expected_size(self, data):
         """获取包含在途订单的【预期仓位】，防止底层下单方法出现认知撕裂"""
         pos_size = self.get_position(data).size
         try:
-            pending_orders = self.get_pending_orders()
+            pending_orders = self._fetch_pending_orders_with_retry(reason="get_expected_size")
             for po in pending_orders:
                 sym = str(po['symbol']).upper()
                 data_name = data._name.upper()
@@ -658,33 +1558,69 @@ class BaseLiveBroker(ABC):
             print(f"[Broker] 获取预期仓位异常: {e}")
         return pos_size
 
-    def process_deferred_orders(self):
+    def process_deferred_orders(self, assume_sell_cleared=False):
         """资金回笼触发重试"""
-        if not self._deferred_orders: return
-        print(f"[Broker] 资金回笼，重试 {len(self._deferred_orders)} 个延迟单...")
-        retry_list = self._deferred_orders[:]
-        self._deferred_orders.clear()
+        # 无人值守风控约束：
+        # 不确定模式下允许恢复/对账，但禁止通过 deferred 重放新增 BUY 风险。
+        if self.is_uncertain_mode():
+            print("[Broker Safety] Deferred replay skipped due to uncertain mode.")
+            return
+
+        # 只有在明确“卖单已出清”时才允许回放 deferred 买单。
+        if not assume_sell_cleared:
+            if not self._can_replay_deferred(reason="process_deferred_orders"):
+                print("[Broker Safety] Deferred replay skipped: pending sell not cleared.")
+                return
+
+        with self._ledger_lock:
+            if not self._deferred_orders:
+                self._drain_buffered_rejected_retries(reason="deferred_empty")
+                return
+            print(f"[Broker] 资金回笼，重试 {len(self._deferred_orders)} 个延迟单...")
+            retry_list = self._deferred_orders[:]
+            self._deferred_orders.clear()
 
         # 这里的 item 结构现在是通用的 {'func': func, 'kwargs': kwargs}
+        failed_items = []
         for item in retry_list:
             func = item.get('func')
             kwargs = item.get('kwargs', {})
             if func:
-                func(**kwargs)
+                try:
+                    func(**kwargs)
+                except Exception as e:
+                    item['fail_count'] = int(item.get('fail_count', 0) or 0) + 1
+                    failed_items.append(item)
+                    print(
+                        f"[Broker] WARNING: Deferred replay failed ({func.__name__ if hasattr(func, '__name__') else 'unknown'}) "
+                        f"attempt={item['fail_count']}. Error: {e}"
+                    )
+
+        if failed_items:
+            with self._ledger_lock:
+                self._deferred_orders.extend(failed_items)
+            print(f"[Broker] Deferred replay recovered: re-queued {len(failed_items)} failed item(s).")
+
+        with self._ledger_lock:
+            self._drain_buffered_rejected_retries(reason="deferred_replayed")
 
     def _add_deferred(self, func, kwargs):        # 捕获闭包参数
-        self._deferred_orders.append({
-            'func': func,
-            'kwargs': kwargs
-        })
+        with self._ledger_lock:
+            self._deferred_orders.append({
+                'func': func,
+                'kwargs': kwargs,
+                'created_at': time.time(),
+                'fail_count': 0,
+            })
 
     def get_cash(self):
         """公有接口：获取资金"""
-        # 扣除本地已经花掉的钱，防止穿透
+        # 先锁外查真实资金，再锁内扣虚拟占资，避免长耗时 I/O 把状态机锁住。
+        real_cash = self._fetch_real_cash()
         with self._ledger_lock:
-            real_cash = self._fetch_real_cash() - getattr(self, '_virtual_spent_cash', 0.0)
-            if real_cash < 0:
-                real_cash = 0.0
+            real_cash -= getattr(self, '_virtual_spent_cash', 0.0)
+        if real_cash < 0:
+            real_cash = 0.0
 
         if self._cash_override is not None:
             return min(real_cash, self._cash_override)
@@ -698,7 +1634,27 @@ class BaseLiveBroker(ABC):
         return self.get_cash()
 
     def _has_pending_sells(self):
-        return len(self._pending_sells) > 0
+        if len(self._pending_sells) > 0:
+            return True
+
+        # 回调丢失兜底：直接询问柜台是否仍存在卖单在途
+        try:
+            pending_orders = self._fetch_pending_orders_with_retry(reason="has_pending_sells")
+        except Exception:
+            # 保守优先：在途快照异常时视为“仍可能有卖单在途”。
+            return True
+
+        for po in pending_orders or []:
+            if not isinstance(po, dict):
+                continue
+            direction = str(po.get('direction', '')).upper()
+            if direction == 'SELL':
+                try:
+                    if float(po.get('size', 0) or 0) > 0:
+                        return True
+                except Exception:
+                    return True
+        return False
 
     def sync_balance(self):
         self._cash = self._fetch_real_cash()
@@ -782,6 +1738,11 @@ class BaseLiveBroker(ABC):
             # 重新计算 target_percent，所以即使保留下来，也会用最新的价格重新下单，是安全的。
 
         self._datetime = dt
+        try:
+            # 每次时间推进都尝试做一次轻量自愈，降低“依赖单点回调”的风险。
+            self.self_heal(reason="set_datetime")
+        except Exception as e:
+            print(f"[Broker Heal] Warning: self_heal failed at set_datetime: {e}")
 
     @property
     def datetime(self):
@@ -816,6 +1777,28 @@ class BaseLiveBroker(ABC):
             self._active_buys.clear()
         if hasattr(self, '_buffered_rejected_retries'):
             self._buffered_rejected_retries.clear()
+        if hasattr(self, '_order_state_memory'):
+            self._order_state_memory.clear()
+        if hasattr(self, '_active_buy_empty_snapshots'):
+            self._active_buy_empty_snapshots = 0
+        if hasattr(self, '_pending_sell_empty_snapshots'):
+            self._pending_sell_empty_snapshots = 0
+        if hasattr(self, '_pending_sell_empty_since'):
+            self._pending_sell_empty_since = None
+        if hasattr(self, '_active_buy_empty_since'):
+            self._active_buy_empty_since = None
+        if hasattr(self, '_strategy_deferred_empty_since'):
+            self._strategy_deferred_empty_since = None
+        if hasattr(self, '_last_deferred_replay_ts'):
+            self._last_deferred_replay_ts = 0.0
+        if hasattr(self, '_pending_snapshot_fail_count'):
+            self._pending_snapshot_fail_count = 0
+        if hasattr(self, '_pending_snapshot_fail_since'):
+            self._pending_snapshot_fail_since = None
+        if hasattr(self, '_uncertain_mode_until'):
+            self._uncertain_mode_until = 0.0
+        if hasattr(self, '_last_uncertain_replay_skip_log_ts'):
+            self._last_uncertain_replay_skip_log_ts = 0.0
 
         # 4. 清理虚拟占资，避免长中断后出现幽灵冻结资金
         self._virtual_spent_cash = 0.0
@@ -835,6 +1818,28 @@ class BaseLiveBroker(ABC):
             self._active_buys.clear()
         if hasattr(self, '_buffered_rejected_retries'):
             self._buffered_rejected_retries.clear()
+        if hasattr(self, '_order_state_memory'):
+            self._order_state_memory.clear()
+        if hasattr(self, '_active_buy_empty_snapshots'):
+            self._active_buy_empty_snapshots = 0
+        if hasattr(self, '_pending_sell_empty_snapshots'):
+            self._pending_sell_empty_snapshots = 0
+        if hasattr(self, '_pending_sell_empty_since'):
+            self._pending_sell_empty_since = None
+        if hasattr(self, '_active_buy_empty_since'):
+            self._active_buy_empty_since = None
+        if hasattr(self, '_strategy_deferred_empty_since'):
+            self._strategy_deferred_empty_since = None
+        if hasattr(self, '_last_deferred_replay_ts'):
+            self._last_deferred_replay_ts = 0.0
+        if hasattr(self, '_pending_snapshot_fail_count'):
+            self._pending_snapshot_fail_count = 0
+        if hasattr(self, '_pending_snapshot_fail_since'):
+            self._pending_snapshot_fail_since = None
+        if hasattr(self, '_uncertain_mode_until'):
+            self._uncertain_mode_until = 0.0
+        if hasattr(self, '_last_uncertain_replay_skip_log_ts'):
+            self._last_uncertain_replay_skip_log_ts = 0.0
         self._virtual_spent_cash = 0.0
 
         try:
